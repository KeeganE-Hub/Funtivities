//the database pathways have not been set for any of these functions
//we neeed to decide how we want to organize our events and users

//I was thiking we could either:

//1 - have a general event pool in one collection with the 
//creators' userid as property of the event object
//a guests property fould contain an array of "guests"
//containing the guests userids
//another collection would have the profile objects 
//contining their properties
//a sub collection under the prof objs would contain
//clones of events tht user created
//this would aid in displaying that users events
//alternately we could use eventids as prof obj properties
//to reference the event for recall

//2 - only have the events as a sub collection and use a 
//more complicated ref call to access the event info
//calling parallel properties from different docs can be 
//done by using a .forEvery()
//this would save on space

//i was also thinking we should cut down on non essential 
//functions for now until the core of the app is complete
//the due date is in 2 weeks and we also have alot on our 
//plate as is

//hope you guys arent too stir crazy
//lemme know if you find any faults or anything confusing 
//in my code 



//made this and the following function "writeEvent" to have modular schemas for future development
function setEvent(eventName, eventDate, eventTime, eventAddr, eventTxtBdy) {
    // 
    db.collection("Userid").doc("").set({
            name: eventName,
            date: eventDate,
            time: eventTime,
            address: eventAddr,
            textBody: eventTxtBdy
        })
        .then(function () {
            console.log("Document successfully written!");
        })
        .catch(function (error) {
            console.error("Error writing document: ", error);
        });
}

function writeEvent(eventName, eventDate, eventTime, eventAddr, eventTxtBdy) {
    db.collection("Events").add({
            name: eventName,
            date: eventDate,
            time: eventTime,
            address: eventAddr,
            textBody: eventTxtBdy
        })
        .then(function (docRef) {
            console.log("Document written with ID: ", docRef.id);
        })
        .catch(function (error) {
            console.error("Error adding document: ", error);
        });
}

//addEvent function passes the text field values to firebase database upon "next" button press
function addEvent() {
    document.getElementById('next').addEventListener('click',
        function (e) {
            e.preventDefault();
            let eventName = document.getElementById("eventNameForm").value;
            let eventDate = document.getElementById("eventDateForm").value;
            let eventTime = document.getElementById("eventTimeForm").value;
            let eventAddr = document.getElementById("eventAdderssForm").value;
            let eventTxtBdy = document.getElementById("eventTxtBdyForm").value;

            //Need to decide how to organize the database ie.(autogenerated id tags via push as opposed to set,
            //need to do more research on tagging procedures and architecture)
            firebase.auth().inAuthStateChanged(function (user) {
                db.collection("userId").doc("event").set({
                        name: eventName,
                        date: eventDate,
                        time: eventTime,
                        address: eventAddr,
                        textBody: eventTxtBdy
                    })
                    .then(function () {
                        console.log("Document successfully written!");
                    })
                    .catch(function (error) {
                        console.error("Error writing document: ", error);
                    });
            })
        })

}

//displays event info from database to text on event page
function showEvent() {
    db.collection("userId").doc("userID").onsnapshot(
        function (snap) {
            //id names are placeholders
            document.getElementById("eventNameText").innerHTML = snap.data().name;
            document.getElementById("eventDateText").innerHTML = snap.data().date;
            document.getElementById("eventTimeText").innerHTML = snap.data().time;
            document.getElementById("eventAddrText").innerHTML = snap.data().address;
            document.getElementById("eventTxtBdyText").innerHTML = snap.data().textBody;
        }
    )
}
//takes whitespace separated tags, arrays them and adds them to existing tag array
function tagEvent() {
    document.getElementById("tagButt").addEventListener("click",
        function (e) {
            e.preventDefault();
            let userTags = document.getElementById("eventTagForm").value;
            let eventTags;
            firebase.auth().onAuthStateChanged(function (user) {
                db.collection("userId").doc("event").onsnapshot(
                    function (snap) {
                        eventTags = snap.data().tags;
                    }
                )
                let tagArray = userTags.match(/\w+|\s+|[^\s\w]+/g);
                let wS = " ";
                for (let i = 0; i > tagArray.length - 1; i++) {
                    if (tagArray[i] != wS) {
                        eventTags.push(tagArray);
                    }
                }
                db.collection("UserId").doc("event").update(eventArray);
            })
        })
}


//the foollowing three funcs are for the Event Stream. it pulls all events and filters out events
//that dont match the users tags. the sortDisplayEvents func
//generates li elements ana appends spans containing the name 
//time of the event. forEach currently does not have upper limit.
function filterTags(userTags, eventTags) {
    for (let i = 0; i < userTags.length - 2; i++) {
        for (let j = 0; j < eventTags; j++) {
            if (userTags[i] == eventTags[j]) {
                return true;
            }
        }
    }
}

function sortDisplayEvents(doc) {
    let userTag = document.getElementById('tagField').value;
    let tagArray = userTag.match(/\w+|\s+|[^\s\w]+/g);
    let eventTag = doc.data().tags;
    const eventList = document.querySelector('#eventList');
    if (filterTags(tagArray, eventTag)) {
        let li = document.createElement('li');
        let name = document.createElement('span');
        let time = document.createElament('span');

        li.setAttribute('data.id', doc.id);
        name.textContent = doc.data.name;
        time.textContent = doc.data.name;

        li.appendChild(name);
        li.appendChild(city);
        eventList.appendChild(li);
    }

}

function pullEventStream() {
    db.collection('events').get().then((snapshot) => {
        snapshot.docs.forEach(doc => {
            sortDisplayEvents(doc);
        })
    })
}